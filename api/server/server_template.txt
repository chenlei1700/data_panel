"""
Author: chenlei  
Date: {date}
Description: {description}è‚¡ç¥¨ä»ªè¡¨ç›˜æœåŠ¡ - åŸºäºæ–°æ¡†æ¶é‡æ„ç‰ˆæœ¬
åŠŸèƒ½: æä¾›{description}ã€è‚¡ç¥¨æ•°æ®å±•ç¤ºã€å®æ—¶æ¶¨å¹…åˆ†æã€æ¶¨åœç›‘æ§ç­‰åŠŸèƒ½
"""

import time
import pandas as pd
import numpy as np
import json
import pickle
import datetime
import plotly
import plotly.graph_objects as go
import os
import sys
import queue
import hashlib
from typing import Dict, Any
from flask import request, Response, jsonify
from flask_cors import CORS

# å¯¼å…¥æ–°æ¡†æ¶åŸºç±»
from .base_server import BaseStockServer
from ..config.server_config import get_server_config, create_auto_update_config
from ..processors.processor_factory import create_processor_manager

# å¯¼å…¥é…ç½®é©±åŠ¨æ¶æ„
from ..config.component_config_multi import ComponentManager
from ..config.source_data_mixin import SourceDataLogicMixin

# å°†é¡¹ç›®æ ¹ç›®å½•æ·»åŠ åˆ°sys.path
current_dir = os.path.dirname(os.path.abspath(__file__))
api_dir = os.path.dirname(current_dir)
project_root = os.path.dirname(os.path.dirname(api_dir))
sys.path.insert(0, project_root)
sys.path.insert(0, api_dir)

# å¯¼å…¥è‚¡ç¥¨æ•°æ®å’Œç­–ç•¥å‡½æ•°
from utils.common import get_trade_date_by_offset
from stock_data.stock.stock_daily import StockDailyData
from stock_data.stock_minute import StockMinuteData
from strategy.strategy001.æ¿å—ä¿¡æ¯æ˜¾ç¤º import plot_stock_line_charts

class {class_name}StockServer(BaseStockServer, SourceDataLogicMixin):
    """{description}è‚¡ç¥¨æœåŠ¡å™¨ - ç»§æ‰¿è‡ªBaseStockServerï¼Œä½¿ç”¨åŸºç±»çš„ç¼“å­˜æœºåˆ¶ï¼Œé›†æˆé…ç½®é©±åŠ¨æ¶æ„"""
    
    def __init__(self, server_type="{server_type}", port=None, auto_update_config=None):
        # åŠ¨æ€è·å–æœåŠ¡å™¨é…ç½®
        server_config = get_server_config(server_type)
        
        # ä½¿ç”¨é…ç½®æ–‡ä»¶ä¸­çš„ç«¯å£ï¼Œå¦‚æœæœªæŒ‡å®šåˆ™ä½¿ç”¨å‚æ•°æˆ–é»˜è®¤å€¼
        if port is None:
            port = server_config.get("port", {default_port})
        
        # ä½¿ç”¨é…ç½®æ–‡ä»¶ä¸­çš„è‡ªåŠ¨æ›´æ–°é…ç½®ï¼Œå…è®¸å‚æ•°è¦†ç›–
        if auto_update_config is None:
            auto_update_config = server_config.get("auto_update_config", {{}})
        else:
            # åˆå¹¶é…ç½®æ–‡ä»¶é…ç½®å’Œå‚æ•°é…ç½®
            file_config = server_config.get("auto_update_config", {{}})
            file_config.update(auto_update_config)
            auto_update_config = file_config
        
        server_name = server_config.get("name", "{description}")
        
        # å…ˆåˆå§‹åŒ–ComponentManageréœ€è¦çš„å±æ€§
        self.dynamic_titles = {{
            "table2": "è‚¡ç¥¨æ•°æ®è¡¨",
            "table21": "è‚¡ç¥¨æ•°æ®è¡¨", 
            "table22": "è‚¡ç¥¨æ•°æ®è¡¨", 
            "table23": "è‚¡ç¥¨æ•°æ®è¡¨", 
            "table24": "è‚¡ç¥¨æ•°æ®è¡¨",
            "table12": "èˆªè¿æ¦‚å¿µ"
        }}
        
        # åœ¨è°ƒç”¨çˆ¶ç±»initä¹‹å‰å…ˆåˆå§‹åŒ–ç»„ä»¶ç®¡ç†å™¨ï¼Œå› ä¸ºregister_custom_routesä¼šåœ¨çˆ¶ç±»initä¸­è¢«è°ƒç”¨
        # ä½¿ç”¨åŠ¨æ€çš„æœåŠ¡å™¨ç±»å‹
        self.component_manager = ComponentManager(self, server_type)
        
        super().__init__(port=port, name=server_name, auto_update_config=auto_update_config)
        
        # æœåŠ¡ç‰¹å®šçš„é…ç½®
        # data_cacheå·²ç»åœ¨åŸºç±»ä¸­é€šè¿‡get_data_cache_file_paths()åˆå§‹åŒ–äº†
        # response_cacheå·²ç»åœ¨åŸºç±»ä¸­åˆå§‹åŒ–äº†ï¼Œæ— éœ€é‡å¤åˆå§‹åŒ–
        
        self.selected_sector = "èˆªè¿æ¦‚å¿µ"
        self.latest_update = {{
            "sector": "èˆªè¿æ¦‚å¿µ",
            "componentId": "chart2", 
            "timestamp": time.time()
        }}
        self.sse_clients = []
        self.message_queue = queue.Queue()
        
        # åˆå§‹åŒ–è‚¡ç¥¨æ•°æ®
        self._init_stock_data()
        
        # è¯»å–è‡ªå®šä¹‰æ¿å—
        self.my_plate_list = self._get_my_plate()
        
        # åˆå§‹åŒ–å¤„ç†å™¨ç®¡ç†å™¨ - ä½¿ç”¨åŠ¨æ€çš„æœåŠ¡å™¨ç±»å‹
        self.processor_manager = create_processor_manager(
            server_type=server_type,
            server_instance=self,
            data_cache=self.data_cache,
            logger=self.logger
        )
        
        # åŠ¨æ€åˆ›å»ºå¤„ç†æ–¹æ³•
        self.component_manager.create_handler_methods()

    def get_data_cache_file_paths(self) -> Dict[str, str]:
        """é‡å†™åŸºç±»æ–¹æ³•ï¼Œæä¾›è‚¡ç¥¨æ•°æ®ç›¸å…³çš„æ–‡ä»¶è·¯å¾„é…ç½®"""
        return {{
            'stock_df': 'strategy\\showhtml\\server\\stock_df.csv',
            'affinity_df': 'strategy\\strategy001\\data\\æ¿å—å†…è‚¡ç¥¨åŒæ¶¨ç‡_é•¿å‘¨æœŸ.csv',
            'plate_df': 'strategy\\showhtml\\server\\good_plate_df.csv',
            'stock_minute_df': 'strategy\\showhtml\\server\\stock_minute_df.csv',
            'up_limit_df': 'strategy\\showhtml\\server\\up_limit_df.csv',
            'stock_all_level_df': 'strategy\\strategy001\\data\\all_sectors_stock_level.csv',
        }}

    def _get_source_data_for_endpoint(self, endpoint: str) -> Dict[str, Any]:
        """é‡å†™æºæ•°æ®è·å–æ–¹æ³•ï¼Œä½¿ç”¨é…ç½®é©±åŠ¨çš„æºæ•°æ®é€»è¾‘"""
        # è·å–è¯·æ±‚å‚æ•°
        request_params = dict(request.args) if hasattr(request, 'args') else {{}}
        
        # ä½¿ç”¨ç»„ä»¶ç®¡ç†å™¨è·å–æºæ•°æ®é€»è¾‘
        source_data = self.component_manager.get_source_data_logic(endpoint, request_params)
        
        if source_data:
            return source_data
        
        # ä½¿ç”¨åŸºç±»çš„é»˜è®¤å®ç°ä½œä¸ºåå¤‡
        return super()._get_source_data_for_endpoint(endpoint)

    def _init_stock_data(self):
        """åˆå§‹åŒ–è‚¡ç¥¨æ•°æ®"""
        try:
            self.stock_daily_ins = StockDailyData()
            today = datetime.datetime.now().strftime("%Y%m%d")
            today = '20250530'  # for test
            yesterday = get_trade_date_by_offset(today, 1)
            self.stock_daily_df = self.stock_daily_ins.get_daily_data(
                start_date=yesterday, end_date=yesterday
            )
            self.logger.info(f"è‚¡ç¥¨æ•°æ®åˆå§‹åŒ–å®Œæˆï¼Œè·å– {{len(self.stock_daily_df)}} æ¡è®°å½•")
        except Exception as e:
            self.logger.error(f"è‚¡ç¥¨æ•°æ®åˆå§‹åŒ–å¤±è´¥: {{e}}")
            self.stock_daily_df = pd.DataFrame()

    def _get_my_plate(self, path=r'api\è‡ªå®šä¹‰ä¼˜å…ˆæ¿å—.txt'):
        """è¯»å–è‡ªå®šä¹‰ä¼˜å…ˆæ¿å—"""
        try:
            with open(path, 'r', encoding='utf-8') as f:
                my_plate = f.read().strip()
                my_plate = my_plate.replace('\n', '').replace('\r', '')
                if my_plate:
                    return my_plate.split(',')
                else:
                    return []
        except Exception as e:
            self.logger.warning(f"è¯»å–è‡ªå®šä¹‰ä¼˜å…ˆæ¿å—å¤±è´¥: {{e}}")
            return []

    def get_dashboard_config(self):
        """è·å–ä»ªè¡¨ç›˜é…ç½® - ä½¿ç”¨é…ç½®é©±åŠ¨æ¶æ„"""
        # åˆå§‹åŒ–åŠ¨æ€æ ‡é¢˜
        if not self.dynamic_titles or all(title == "è‚¡ç¥¨æ•°æ®è¡¨" for title in self.dynamic_titles.values() if 'table' in str(title)):
            self._update_dynamic_titles()
            self.logger.info("åˆå§‹åŒ–åŠ¨æ€æ ‡é¢˜")
        else:
            self.logger.info(f"ä½¿ç”¨ç°æœ‰åŠ¨æ€æ ‡é¢˜: {{self.dynamic_titles}}")
        
        # ä½¿ç”¨ç»„ä»¶ç®¡ç†å™¨ç”Ÿæˆé…ç½®
        return self.component_manager.get_dashboard_config()

    def get_data_sources(self):
        """è·å–æ•°æ®æºé…ç½® - ä½¿ç”¨é…ç½®é©±åŠ¨æ¶æ„"""
        return self.component_manager.get_data_sources_config()

    def register_custom_routes(self):
        """æ³¨å†Œè‡ªå®šä¹‰è·¯ç”± - é…ç½®é©±åŠ¨ç‰ˆæœ¬ï¼Œå¸¦è¯¦ç»†æ—¥å¿—"""
        
        # ä»ç»„ä»¶é…ç½®ä¸­è‡ªåŠ¨æå–æ‰€æœ‰APIè·¯å¾„å¹¶æ³¨å†Œè·¯ç”±
        if hasattr(self, 'component_manager') and self.component_manager:
            self.logger.info("å¼€å§‹é…ç½®é©±åŠ¨çš„è·¯ç”±æ³¨å†Œ")
            
            # è·å–å½“å‰æœåŠ¡å™¨ç±»å‹çš„æ‰€æœ‰ç»„ä»¶é…ç½®
            components = self.component_manager.components
            self.logger.info(f"è·å–åˆ° {{len(components)}} ä¸ªç»„ä»¶é…ç½®")
            
            # ä¸ºæ¯ä¸ªç»„ä»¶çš„APIè·¯å¾„æ³¨å†Œè·¯ç”±
            registered_count = 0
            for component_id, component_config in components.items():
                # æ£€æŸ¥ç»„ä»¶æ˜¯å¦å¯ç”¨ï¼ˆenabled å­—æ®µåœ¨ extra_config ä¸­ï¼‰
                enabled = component_config.extra_config.get('enabled', True)
                
                if not enabled:
                    self.logger.info(f"è·³è¿‡æœªå¯ç”¨çš„ç»„ä»¶: {{component_id}}")
                    continue  # è·³è¿‡æœªå¯ç”¨çš„ç»„ä»¶
                
                api_path = component_config.api_path
                
                # ä» api_path æå–æ–¹æ³•å
                if api_path.startswith('/api/'):
                    method_name = api_path[5:]  # å»æ‰ "/api/" å‰ç¼€
                else:
                    method_name = api_path
                
                # åˆ›å»ºè·¯ç”±å¤„ç†å‡½æ•°
                def create_route_handler(method_name):
                    """åˆ›å»ºè·¯ç”±å¤„ç†å‡½æ•°ï¼Œé¿å…é—­åŒ…é—®é¢˜"""
                    def handler():
                        return self.processor_manager.process(method_name)
                    return handler
                
                # æ³¨å†Œè·¯ç”±
                self.app.add_url_rule(
                    api_path,  # ä½¿ç”¨é…ç½®æ–‡ä»¶ä¸­çš„å®Œæ•´è·¯å¾„
                    method_name,  # è·¯ç”±åç§°
                    create_route_handler(method_name),
                    methods=['GET', 'POST']
                )
                
                self.logger.info(f"å·²æ³¨å†Œè·¯ç”±: {{api_path}} -> {{method_name}}")
                registered_count += 1
            
            self.logger.info(f"é…ç½®é©±åŠ¨è·¯ç”±æ³¨å†Œå®Œæˆï¼Œå…±æ³¨å†Œ {{registered_count}} ä¸ªè·¯ç”±")
           
        
        # æ³¨å†ŒSSEå’Œæ›´æ–°ç›¸å…³è·¯ç”±
        self.app.add_url_rule('/api/dashboard/update',
                             'update_dashboard',
                             self.update_dashboard, methods=['POST'])
        
        self.app.add_url_rule('/api/dashboard/updates',
                             'dashboard_updates',
                             self.dashboard_updates, methods=['GET'])
        
        self.app.add_url_rule('/api/dashboard/notify-update',
                             'notify_update', 
                             self.notify_update, methods=['POST'])
        
        self.app.add_url_rule('/api/debug/dynamic-titles',
                             'get_dynamic_titles_debug',
                             self.get_dynamic_titles_debug, methods=['GET'])
        
        # ç¼“å­˜ç®¡ç†è·¯ç”±
        self.app.add_url_rule('/api/cache/status',
                             'get_cache_status',
                             self.get_cache_status, methods=['GET'])
        
        self.app.add_url_rule('/api/cache/clear',
                             'clear_cache',
                             self.clear_cache, methods=['POST'])

    # ===== æ•°æ®å¤„ç†æ–¹æ³• =====
    # æ³¨æ„ï¼šå¤„ç†æ–¹æ³•ç°åœ¨ç”±ComponentManagerè‡ªåŠ¨åˆ›å»ºï¼Œæ— éœ€æ‰‹åŠ¨å®šä¹‰
    # å¦‚éœ€è‡ªå®šä¹‰ç‰¹æ®Šé€»è¾‘ï¼Œå¯ä»¥åœ¨è¿™é‡Œé‡å†™å¯¹åº”æ–¹æ³•
    def get_cache_status(self):
        """è·å–ç¼“å­˜çŠ¶æ€"""
        return self.response_cache.get_cache_status()
    def clear_cache(self):
        """æ¸…é™¤ç¼“å­˜"""
        self.response_cache.clear_cache()
        return jsonify({{"status": "success", "message": "ç¼“å­˜å·²æ¸…é™¤"}})
    def get_dynamic_titles(self):
        """è·å–å½“å‰åŠ¨æ€æ ‡é¢˜"""
        return jsonify(self.dynamic_titles)
    def get_selected_sector(self):
        """è·å–å½“å‰é€‰ä¸­çš„æ¿å—åç§°"""
        return jsonify({{"selected_sector": self.selected_sector}})
    def get_latest_update(self):
        """è·å–æœ€æ–°æ›´æ–°ä¿¡æ¯"""
        return jsonify(self.latest_update)
    
    # ===== SSE å’Œæ›´æ–°ç›¸å…³æ–¹æ³• =====
    
    def update_dashboard(self):
        """æ¥æ”¶é¡µé¢æ›´æ–°è¯·æ±‚"""
        data = request.json
        self.logger.info(f"æ”¶åˆ°æ›´æ–°è¯·æ±‚: {{data}}")
        
        params = data.get('params', {{}})
        if isinstance(params, dict):
            sector_name = params.get('sectors', 'èˆªè¿æ¦‚å¿µ')
        else:
            sector_name = str(params) if params else 'èˆªè¿æ¦‚å¿µ'
        
        self.selected_sector = sector_name
        self.dynamic_titles['table12'] = sector_name
        
        self.latest_update = {{
            "componentId": data.get('componentId', 'chart2'),
            "params": params,
            "timestamp": time.time(),
            "action": "config_update",
            "sector_name": sector_name
        }}
        
        update_message = {{
            "action": "reload_config",
            "sector_name": sector_name,
            "timestamp": time.time()
        }}
        self._send_update_to_clients(update_message)
        
        return jsonify({{
            "status": "success",
            "message": "Update request sent",
            "sector_name": sector_name,
            "updated_titles": self.dynamic_titles
        }})

    def dashboard_updates(self):
        """SSEäº‹ä»¶æµ"""
        def event_stream():
            client_queue = queue.Queue()
            client_id = f"client_{{len(self.sse_clients)}}_{{time.time()}}"
            
            try:
                self.sse_clients.append(client_queue)
                self.logger.info(f"SSEå®¢æˆ·ç«¯è¿æ¥: {{client_id}}ï¼Œå½“å‰æ€»è¿æ¥æ•°: {{len(self.sse_clients)}}")
                
                connection_info = {{
                    "type": "connection_established",
                    "client_id": client_id,
                    "timestamp": time.time(),
                    "server_status": "online"
                }}
                yield f"data: {{json.dumps(connection_info)}}\\n\\n"
                
                # ä¸å†è‡ªåŠ¨å‘é€latest_updateï¼Œé¿å…æ— å·®åˆ«åˆ·æ–°
                # åªåœ¨æœ‰å®é™…æ›´æ–°æ—¶æ‰å‘é€
                # yield f"data: {{json.dumps(self.latest_update)}}\\n\\n"
                
                while True:
                    try:
                        message = client_queue.get(block=True, timeout=10)
                        yield message
                    except queue.Empty:
                        heartbeat = {{
                            "type": "heartbeat",
                            "client_id": client_id,
                            "timestamp": time.time(),
                            "server_time": datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                            "active_connections": len(self.sse_clients)
                        }}
                        yield f"data: {{json.dumps(heartbeat)}}\\n\\n"
                        continue
                    except GeneratorExit:
                        self.logger.info(f"SSEå®¢æˆ·ç«¯ä¸»åŠ¨æ–­å¼€: {{client_id}}")
                        break
                        
            except Exception as e:
                self.logger.error(f"SSEè¿æ¥å¼‚å¸¸ {{client_id}}: {{e}}")
            finally:
                if client_queue in self.sse_clients:
                    self.sse_clients.remove(client_queue)
                    self.logger.info(f"SSEå®¢æˆ·ç«¯æ¸…ç†: {{client_id}}ï¼Œå‰©ä½™è¿æ¥æ•°: {{len(self.sse_clients)}}")
        
        response = Response(event_stream(), mimetype="text/event-stream")
        response.headers.update({{
            'Cache-Control': 'no-cache, no-store, must-revalidate',
            'Pragma': 'no-cache',
            'Expires': '0',
            'X-Accel-Buffering': 'no',
            'Connection': 'keep-alive',
            'Access-Control-Allow-Origin': '*',
            'Access-Control-Allow-Headers': 'Cache-Control',
            'Keep-Alive': 'timeout=30, max=1000'
        }})
        return response

    def notify_update(self):
        """æ¥æ”¶æ›´æ–°é€šçŸ¥å¹¶é€šè¿‡SSEå¹¿æ’­"""
        data = request.json
        
        try:
            top_sectors = self._update_dynamic_titles()
            self.logger.info(f"æ¶¨å¹…å‰5æ¿å—: {{top_sectors}}")
            self.logger.info(f"åŠ¨æ€æ ‡é¢˜å·²æ›´æ–°: {{self.dynamic_titles}}")
        except Exception as e:
            self.logger.error(f"notify_updateä¸­æ›´æ–°æ ‡é¢˜å¤±è´¥: {{e}}")
        
        update_message = {{
            "action": "reload_config",
            "sector_name": self.selected_sector,
            "timestamp": time.time()
        }}
        
        self._send_update_to_clients(update_message)
        return jsonify({{
            "status": "success",
            "message": "æ›´æ–°é€šçŸ¥å·²å‘é€ï¼Œå‰ç«¯å°†é‡æ–°åŠ è½½é…ç½®"
        }})

    def get_dynamic_titles_debug(self):
        """è°ƒè¯•ç«¯ç‚¹ï¼šè¿”å›å½“å‰çš„åŠ¨æ€æ ‡é¢˜çŠ¶æ€"""
        try:
            top_sectors = self._get_top_sectors()
        except:
            top_sectors = ["è·å–å¤±è´¥"]
        
        return jsonify({{
            "dynamic_titles": self.dynamic_titles,
            "selected_sector": self.selected_sector,
            "latest_update": self.latest_update,
            "current_top_sectors": top_sectors,
            "timestamp": time.time()
        }})

    # ===== è¾…åŠ©æ–¹æ³• =====
    
    def _send_update_to_clients(self, data):
        """å‘é€æ›´æ–°åˆ°æ‰€æœ‰SSEå®¢æˆ·ç«¯"""
        for client in list(self.sse_clients):
            try:
                client.put(f"data: {{json.dumps(data)}}\\n\\n")
            except:
                self.sse_clients.remove(client)

    def _get_dynamic_titles_list(self):
        """è·å–åŠ¨æ€æ ‡é¢˜åˆ—è¡¨"""
        return list(self.dynamic_titles.values())

    def _get_top_sectors(self, n=5):
        """è·å–æ¶¨å¹…å‰nçš„æ¿å—åç§°"""
        try:
            plate_df = self.data_cache.load_data('plate_df')
            if plate_df.empty:
                self.logger.warning("æ¿å—æ•°æ®æ–‡ä»¶è¯»å–å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤æ¿å—")
                return ["èˆªè¿æ¦‚å¿µ", "å¯æ§æ ¸èšå˜", "å†›å·¥"]
                
            plate_df['æ—¶é—´'] = pd.to_datetime(plate_df['æ—¶é—´'])
            latest_time = plate_df['æ—¶é—´'].max()
            plate_df = plate_df[plate_df['æ—¶é—´'] == latest_time]
            
            top_sectors = plate_df.sort_values(by='æ¿å—æ¶¨å¹…', ascending=False).head(n)
            top_sectors_list = top_sectors['æ¿å—å'].tolist()
            
            # åŠ å…¥è‡ªå®šä¹‰ä¼˜å…ˆæ¿å—
            top_sectors_list = self.my_plate_list + top_sectors_list
            return list(set(top_sectors_list))  # å»é‡
            
        except Exception as e:
            self.logger.error(f"è·å–æ¶¨å¹…å‰{{n}}æ¿å—å¤±è´¥: {{e}}")
            return ["èˆªè¿æ¦‚å¿µ", "å¯æ§æ ¸èšå˜", "å†›å·¥"]

    def _update_dynamic_titles(self):
        """æ›´æ–°åŠ¨æ€æ ‡é¢˜"""
        try:
            top_sectors = self._get_top_sectors()
            
            while len(top_sectors) < 5:
                top_sectors.append("é»˜è®¤æ¿å—")
            
            current_table12 = self.dynamic_titles.get("table12", self.selected_sector)
            
            self.dynamic_titles.update({{
                "table2": f"{{top_sectors[0]}}",
                "table21": f"{{top_sectors[1]}}",
                "table22": f"{{top_sectors[2]}}",
                "table23": f"{{top_sectors[3]}}",
                "table24": f"{{top_sectors[4]}}",
            }})
            
            self.dynamic_titles["table12"] = current_table12
            
            self.logger.info(f"åŠ¨æ€æ ‡é¢˜å·²æ›´æ–°: {{self.dynamic_titles}}")
            return top_sectors
            
        except Exception as e:
            self.logger.error(f"æ›´æ–°åŠ¨æ€æ ‡é¢˜å¤±è´¥: {{e}}")
            return ["èˆªè¿æ¦‚å¿µ", "å¯æ§æ ¸èšå˜", "å†›å·¥"]

    def _calculate_tail_ratio(self, number_string, n):
        """è®¡ç®—å€’æ•°ånä¸ªæ•°çš„åˆè®¡ä¸æ€»åˆè®¡çš„æ¯”å€¼"""
        try:
            numbers = [float(x) for x in number_string.split('-')]
            total_sum = sum(numbers)
            tail_numbers = numbers[-n:] if n <= len(numbers) else numbers
            tail_sum = sum(tail_numbers)
            
            if total_sum == 0:
                return 0.0
            else:
                return round(tail_sum / total_sum, 2)
        except:
            return 0.0

    def _calculate_center_of_mass(self, number_string):
        """è®¡ç®—æ•°å­—ä¸²çš„é‡å¿ƒä½ç½®"""
        try:
            numbers = [float(x) for x in number_string.split('-')]
            weighted_sum = 0
            value_sum = 0
            
            for index, value in enumerate(numbers):
                position = index + 1
                weighted_sum += position * value
                value_sum += value
            
            if value_sum == 0:
                return 0
            
            return round(weighted_sum / value_sum, 2)
        except:
            return 0


def main():
    """ä¸»å‡½æ•°"""
    print("ğŸš€ å¯åŠ¨{description}è‚¡ç¥¨ä»ªè¡¨ç›˜æœåŠ¡å™¨...")
    
    # ç®€å•é…ç½®ï¼šç¦ç”¨è‡ªåŠ¨æ›´æ–°
    auto_update_config = {{'enabled': False}}
    
    # åˆ›å»ºæœåŠ¡å™¨å®ä¾‹ - ä½¿ç”¨åŠ¨æ€é…ç½®
    server = {class_name}StockServer(
        server_type="{server_type}",  # åŠ¨æ€æœåŠ¡å™¨ç±»å‹
        auto_update_config=auto_update_config
    )
    
    # æ˜¾ç¤ºæœåŠ¡å™¨åŸºæœ¬ä¿¡æ¯ - åŠ¨æ€è·å–
    print(f"ğŸ“‹ ç«¯å£: {{server.port}}")
    print(f"ğŸ“ æœåŠ¡å™¨åç§°: {{server.name}}")
    print(f"ğŸš« è‡ªåŠ¨æ›´æ–°: å·²ç¦ç”¨")
    
    try:
        # å¯åŠ¨æ—¶åˆå§‹åŒ–åŠ¨æ€æ ‡é¢˜
        server._update_dynamic_titles()
        print("âœ… åŠ¨æ€æ ‡é¢˜åˆå§‹åŒ–å®Œæˆ")
    except Exception as e:
        print(f"âš ï¸ åŠ¨æ€æ ‡é¢˜åˆå§‹åŒ–å¤±è´¥: {{e}}")
    
    server.run(debug=True)


if __name__ == '__main__':
    main()
